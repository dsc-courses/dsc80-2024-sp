
# Do NOT edit this file. Instead, just call it from the command line,
# using the instructions in the assignment notebook.

import sys
questions = sys.argv[1:]


valid_ids = ['q1', 'q2', 'q3', 'q4', 'q5', 'q6.1', 'q6.2', 'q6.3']
break_flag = False
invalid_ids = []
for question in questions:
    if question != 'all' and question not in valid_ids:
        invalid_ids.append(question)

if len(invalid_ids) > 0:
    print(str(invalid_ids) + ' is/are not a valid question number(s). The possible question numbers are ' + str(valid_ids) + '.')
    sys.exit()

# Initialize Otter
import otter
grader = otter.Notebook("lab.ipynb")

# %load_ext autoreload
# %autoreload 2

from lab import *

import pandas as pd
import numpy as np
import plotly.express as px
import statsmodels.api as sm
from pathlib import Path
from sklearn.preprocessing import Binarizer, QuantileTransformer, FunctionTransformer

import warnings
warnings.filterwarnings('ignore')

# By setting a seed, we guarantee that we will see the same results each time we run this cell.
np.random.seed(23)

# Generates a random scatter plot
x = np.arange(1, 101) + np.random.normal(0, 0.5, 100)
y = 2 * ((x + np.random.normal(0, 1, 100)) ** 2) + np.abs(x) * np.random.normal(0, 30, 100)
df_1 = pd.DataFrame().assign(x=x, y=y)

px.scatter(df_1, x='x', y='y', trendline="ols", trendline_color_override="red")

df_1['root y'] = np.sqrt(df_1['y'])

px.scatter(df_1, x='x', y='root y', trendline="ols", trendline_color_override="red")

# By setting a seed, we guarantee that we will see the same results each time we run this cell
np.random.seed(32)

# Generates a different random scatter plot
x = np.linspace(2, 5, 100)
y = 10 * (np.e ** x) + np.abs(x) * np.random.normal(0, 5, 100) + np.random.normal(0, 30, 100)
df_2 = pd.DataFrame().assign(x=x, y=y)

px.scatter(df_2, x='x', y='y', trendline="ols", trendline_color_override="red")

df_2['root y'] = np.sqrt(df_2['y'])

px.scatter(df_2, x='x', y='root y', trendline="ols", trendline_color_override="red")

# Feel free to use this function directly to help you answer Question 1.
def create_residual_plot(df, x, y):
    df = df.copy()
    from sklearn.linear_model import LinearRegression
    model = LinearRegression()
    model.fit(df[[x]], df[y])
    df['pred'] = model.predict(df[[x]])
    df[f'{y} residuals'] = df[y] - model.predict(df[[x]])
    return px.scatter(df, x='pred', y=f'{y} residuals', trendline='ols', trendline_color_override='red')

create_residual_plot(df_2, 'x', 'root y')

df_2['log y'] = np.log(df_2['y'])

px.scatter(df_2, x='x', y='log y', trendline="ols", trendline_color_override="red")

create_residual_plot(df_2, 'x', 'log y')

homeruns_fp = Path('data')/'homeruns.csv'
homeruns = pd.read_csv(homeruns_fp)

if 'q1' in questions or questions == [] or 'all' in questions:
    print(grader.check("q1"))

diamonds = pd.read_csv(Path('data')/'diamonds.csv')
diamonds.head()

# don't change this cell, but do run it -- it is needed for the tests to work
diamonds = pd.read_csv(Path('data')/'diamonds.csv')
out_q2 = create_ordinal(diamonds)

if 'q2' in questions or questions == [] or 'all' in questions:
    print(grader.check("q2"))

# don't change this cell, but do run it -- it is needed for the tests to work
diamonds = pd.read_csv(Path('data')/'diamonds.csv')
out1_q3 = create_one_hot(diamonds)
out2_q3 = create_proportions(diamonds)

if 'q3' in questions or questions == [] or 'all' in questions:
    print(grader.check("q3"))

# don't change this cell, but do run it -- it is needed for the tests to work
diamonds = pd.read_csv(Path('data')/'diamonds.csv')
out_q4 = create_quadratics(diamonds)

if 'q4' in questions or questions == [] or 'all' in questions:
    print(grader.check("q4"))

from sklearn.linear_model import LinearRegression

# X = ...
# y = ...

# lr = LinearRegression()
# lr.fit(X, y)  # X is a DataFrame of training data; y is a Series of prices
# lr.score(X, y)  # R-squared
# lr.predict(X) # predicted prices

# don't change this cell, but do run it -- it is needed for the tests to work
import numbers
out_q5 = comparing_performance()

if 'q5' in questions or questions == [] or 'all' in questions:
    print(grader.check("q5"))

from sklearn.preprocessing import Binarizer, QuantileTransformer, FunctionTransformer

# don't change this cell, but do run it -- it is needed for the tests to work
diamonds = pd.read_csv(Path('data')/'diamonds.csv')
q6a_trans = TransformDiamonds(diamonds)
q6a_out = q6a_trans.transform_carat(diamonds)

if 'q6.1' in questions or questions == [] or 'all' in questions:
    print(grader.check("q6.1"))

# don't change this cell, but do run it -- it is needed for the tests to work
q6b_trans = TransformDiamonds(diamonds)
q6b_out = q6b_trans.transform_to_quantile(diamonds)
q6b_trans_top_1000 = TransformDiamonds(diamonds[:1000])
q6b_out_top_1000 = q6b_trans_top_1000.transform_to_quantile(diamonds)

if 'q6.2' in questions or questions == [] or 'all' in questions:
    print(grader.check("q6.2"))

# don't change this cell, but do run it -- it is needed for the tests to work
diamonds = pd.read_csv(Path('data')/'diamonds.csv')
q6c_trans = TransformDiamonds(diamonds)
q6c_out = q6c_trans.transform_to_depth_pct(diamonds)

if 'q6.3' in questions or questions == [] or 'all' in questions:
    print(grader.check("q6.3"))


