
# Do NOT edit this file. Instead, just call it from the command line,
# using the instructions in the assignment notebook.

import sys
questions = sys.argv[1:]


valid_ids = ['q1', 'q2', 'q3', 'q4', 'q5', 'q6', 'q7']
break_flag = False
invalid_ids = []
for question in questions:
    if question != 'all' and question not in valid_ids:
        invalid_ids.append(question)

if len(invalid_ids) > 0:
    print(str(invalid_ids) + ' is/are not a valid question number(s). The possible question numbers are ' + str(valid_ids) + '.')
    sys.exit()

# Initialize Otter
import otter
grader = otter.Notebook("lab.ipynb")

# %load_ext autoreload
# %autoreload 2

from lab import *

from pathlib import Path
import pandas as pd
import numpy as np
from scipy import stats

import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
import plotly.io as pio
pd.options.plotting.backend = 'plotly'

# DSC 80 preferred styles
pio.templates["dsc80"] = go.layout.Template(
    layout=dict(
        margin=dict(l=30, r=30, t=30, b=30),
        autosize=True,
        width=600,
        height=400,
        xaxis=dict(showgrid=True),
        yaxis=dict(showgrid=True),
        title=dict(x=0.5, xanchor="center"),
    )
)
pio.templates.default = "simple_white+dsc80"

def create_kde_plotly(df, group_col, group1, group2, vals_col, title=''):
    fig = ff.create_distplot(
        hist_data=[df.loc[df[group_col] == group1, vals_col], df.loc[df[group_col] == group2, vals_col]],
        group_labels=[group1, group2],
        show_rug=False, show_hist=False
    )
    return fig.update_layout(title=title)

import requests
import bs4

# don't change this cell -- it is needed for the tests to work
out_q1 = after_purchase()

if 'q1' in questions or questions == [] or 'all' in questions:
    print(grader.check("q1"))

# don't change this cell -- it is needed for the tests to work
out_q2 = multiple_choice()

if 'q2' in questions or questions == [] or 'all' in questions:
    print(grader.check("q2"))

# Run your permutation tests in the Jupyter Notebook
# and put your final results in lab.py.
payments_fp = Path('data') / 'payment.csv'
payments = pd.read_csv(payments_fp)
payments.head()

# don't change this cell, but do run it -- it is needed for the tests to work
first_pval, first_result = first_round()
second_pval, second_result, second_result1 = second_round()

if 'q3' in questions or questions == [] or 'all' in questions:
    print(grader.check("q3"))

# don't change this cell, but do run it -- it is needed for the tests to work
heights_fp = Path('data') / 'missing_heights.csv'
heights = pd.read_csv(heights_fp)
out_q4 = verify_child(heights.copy())

if 'q4' in questions or questions == [] or 'all' in questions:
    print(grader.check("q4"))

(
    out_q4
    .to_frame()
    .plot(kind='barh', width=800, height=400, labels={'index': 'column', 'value': 'p-value'})
    .update_layout(showlegend=False)
)

# don't change this cell, but do run it -- it is needed for the tests to work
heights_fp = Path('data') / 'missing_heights.csv'
new_heights = pd.read_csv(heights_fp)[['father', 'child_50']]
new_heights = new_heights.rename(columns={'child_50': 'child'})
out_q5 = cond_single_imputation(new_heights.copy())

# don't change this cell, but do run it -- it is needed for the tests to work
heights_fp = Path('data') / 'missing_heights.csv'
heights_q5 = pd.read_csv(heights_fp)
heights_q5['child'] = heights_q5['child_50']
inp_q5 = heights_q5
out_q5 = cond_single_imputation(inp_q5)
df_q5 = inp_q5.copy()
df_q5['imputed'] = out_q5
gp1_q5 = df_q5.groupby('father')['imputed'].mean()
gp2_q5 = df_q5.groupby('father')['child'].mean()
m_q5 = (pd.concat([gp1_q5, gp2_q5], axis=1)
     .dropna().diff(axis=1).abs().iloc[:, -1])

if 'q5' in questions or questions == [] or 'all' in questions:
    print(grader.check("q5"))

# don't change this cell, but do run it -- it is needed for the tests to work
heights_fp = Path('data') / 'missing_heights.csv'
heights = pd.read_csv(heights_fp)
child = heights['child_50']
quantitative_distribution_out_q6 = quantitative_distribution(child.copy(), 100)
impute_height_quant_out_q6 = impute_height_quant(child.copy())

if 'q6' in questions or questions == [] or 'all' in questions:
    print(grader.check("q6"))

# don't change this cell, but do run it -- it is needed for the tests to work
mc_answers, websites = answers()

# don't change this cell, but do run it -- it is needed for the tests to work
from urllib.parse import urlparse
import urllib.robotparser

# This code checks the robots.txt file
def canFetch(url):
    if url[:4] != 'http':
        url = 'https://' + url
    parsed_uri = urlparse(url)

    domain = '{uri.scheme}://{uri.netloc}/'.format(uri=parsed_uri)

    rp = urllib.robotparser.RobotFileParser()
    rp.set_url(domain + "/robots.txt")
    try:
        rp.read()
        canFetchBool = rp.can_fetch("*", url)
    except:
        canFetchBool = None
    
    return canFetchBool

ans_q7, websites_q7 = answers()
canfetch_q7 = []
for site in websites_q7:
    try:
        canfetch_q7.append(canFetch(site))
    except:
        canfetch_q7.append(None)

if 'q7' in questions or questions == [] or 'all' in questions:
    print(grader.check("q7"))


